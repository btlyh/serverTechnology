# 数据结构与算法

## 数据结构：

### 数组：
连续的一组数据，在内存中的分配也是连续的，每个数组中的元素都有其下标，  
用于标识其元素在组中的位置。数组长度不可变，当修改数组时，其本质是复制  
一个新的数组做返回
#### 特点：
1. 查找数据快，直接使用下标，时间复杂度O(1)  

2. 修改慢，因为数组的修改意味着重新生成一个新的数组

### 栈
栈是一种特殊的线性表，只允许操作栈顶，和弹夹一模一样，当装子弹时，其实  
就是操作数据入栈，开枪时，就是操作数据出栈。（先进后出）

### 队列
队列和栈一样，也是一种线性表，不同的是，队列可以在一端加入元素，叫做入  
队。然后被加入的元素在另一端取出，叫做出队。（先进先出）

### 链表
链表是物理存储单元上非连续、非顺序的存储结构。其每个元素包含两个节点，一  
个是包含存储数据的元素，一个是指向下一个元素地址的指针。
#### 特点：
1. 查找数据慢，需要遍历查找目标位置之前的所有元素,时间复杂度O(n)。  

2. 修改快，只需要修改前一个元素的指针指向，和插入元素的指针指向。  

3. 根据指针的指向，链表可以形成不同的链表结构，**单向链表**、**双向链表**、**循环链表**。  

![基础数据结构模型](https://https://github.com/btlyh/serverTechnology/blob/main/img/transaction.png "简单模型")  


## 算法（PS：所有log的底数为2 ）：
如何测算算法的优劣？  
1. 时间测算：计算速度越快，算法越优秀。  

2. 空间测算：计算时所需要额外的空间越小，算法越优秀。

### BIG-O：
BIG-O是指随着问题规模的增加，解决其问题的方法所占用的时间和空间的表示。  

### 常见时间复杂度（效率从高到低）： 

- **O(1)常数介：**当问题增大n倍，花费时间为1 

- **O(logn)对数介：**当问题增大n倍，花费时间为logn倍

- **O(n)线性介：**当问题增大n倍，花费时间为n倍  

- **O(nlogn)nlogn介：**当问题增大n倍，花费时间为n * logn倍  

- **O(n^2)平方介：**当问题增大n倍，花费时间为n * n倍  

- **O(n^3)立方介：**当问题增大n倍，花费时间为n * n * n倍  

- **O(2^n)指数介：**当问题增大n倍，花费时间为2的n次幂倍  

- **O(n!)阶乘介：**当问题增大n倍，花费时间为1 * 2 * 3 ... * n

### 常用排序算法：

| 中文 | 英文 | 平均复杂度 | 最坏复杂度 | 最好复杂度 | 空间复杂度 | 是否稳定 |
| ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| 选择排序 | selection | n^2 | n^2 | n^2 | 1 | false |
| 冒泡排序 | bubble | n^2 | n^2 | n | 1 | true |
| 插入排序 | insertion | n^2 | n^2 | n | 1 | true |
| 堆排序 | heap | nlogn | nlogn | nlogn | 1 | false |
| 壳排序 | shell | n^1.3 | n^2 | n | 1 | false |
| 归并排序 | merge | nlogn | nlogn | nlogn | n | true |
| 快速排序 | quick | nlogn | n^2 | nlogn | logn | false |
| 计数排序 | counting | n+k | n+k | n+k | n+k | true |
| 基数排序 | radix | n * k | n * k | n * k | n+k | true |

### 编写算法思路：
1. 由简单至复杂，逐步验证。  

2. 先局部后整体。  

3. 边界处理，优化可读性。  

### GO代码实现：
```go
// RadixSortTemp 基数排序-低位 O(n * k) 效率吊且稳定，比系统自带快
// 不用二维切片的方式实现，空间复杂度稍低，但是执行效率比用
// 二维切片的方式要慢20%左右
func RadixSortTemp(slice []int) {
	// 取切片中最大值(也可以理解为取关键字最多的那个元素)
	maxValue := math.MinInt32
	for i := 0; i < len(slice); i++ {
		if maxValue < slice[i] {
			maxValue = slice[i]
		}
	}
	// 取值的位数
	digit := 0
	for maxValue != 0 {
		digit++
		maxValue /= 10
	}
	result := make([]int, len(slice))
	// 建桶
	bucket := [10]int{}
	for i := 0; i < digit; i++ {
		division := int(math.Pow10(i))

		// 利于计数排序的思想，做累加切片
		for j := 0; j < len(slice); j++ {
			num := slice[j] / division % 10
			bucket[num]++
		}
		for m := 1; m < len(bucket); m++ {
			bucket[m] = bucket[m] + bucket[m-1]
		}
		for n := len(slice) - 1; n >= 0; n-- {
			num := slice[n] / division % 10
			bucket[num]--
			result[bucket[num]] = slice[n]
		}
		// 将排序结果拷贝至原切片
		copy(slice, result)
		// 重置桶
		bucket = [10]int{}
	}
	// 所有位数排序完成，最终赋值，也可以直接返回result
	slice = result
}

// RadixSort 基数排序-低位 O(n * k) 效率吊且稳定，比系统自带快
// 应用场景一般为字符串排序、多关键字排序等
func RadixSort(slice []int) {
	// 取切片中最大值
	maxValue := math.MinInt32
	for i := 0; i < len(slice); i++ {
		if maxValue < slice[i] {
			maxValue = slice[i]
		}
	}
	// 取值的位数，相当于KEY的个数
	digit := 0
	for maxValue != 0 {
		digit++
		maxValue /= 10
	}
	// 建桶 0 ~ 9 二维切片
	bucket := make([][]int, 10)
	for i := 0; i < digit; i++ {
		// 每次循环，求当前排序的位置
		division := int(math.Pow10(i))
		for j := 0; j < len(slice); j++ {
			// 求位数的值
			num := slice[j] / division % 10
			bucket[num] = append(bucket[num], slice[j])
		}
		// 将桶中的数据从小到大排列
		p := 0
		for j := 0; j < len(bucket); j++ {
			for k := 0; k < len(bucket[j]); k++ {
				slice[p] = bucket[j][k]
				p++
			}
			// 重置桶数据
			bucket[j] = nil
		}
	}
}

// CountSort 计数排序  O(n + k),忽略2倍遍历常数项 , 特殊情况下使用，排序元素的取值要在一定范围内，并且比较集中
func CountSort(slice []int, min int, max int) []int {
	// 创建计数切片,其长度为取值最大-取值最小+1
	countTemp := make([]int, max-min+1)
	// 计数切片开始计数
	for i := 0; i < len(slice); i++ {
		if slice[i] >= min && slice[i] <= max {
			countTemp[slice[i]-min]++
		}
	}
	// 计数切片转换累加切片
	for i := 1; i < len(countTemp); i++ {
		countTemp[i] += countTemp[i-1]
	}
	// 创建和原始切片长度一致的结果切片
	result := make([]int, len(slice))
	// 返回排序之后的新切片(根据累加切片对原始切片进行倒叙迭代)
	for i := len(slice) - 1; i >= 0; i-- {
		if slice[i] >= min && slice[i] <= max {
			result[countTemp[slice[i]-min]-1] = slice[i]
			countTemp[slice[i]-min]--
		}
	}
	return result
}

// QuickSort 快速排序 效率虽吊但是不稳定,赞
func QuickSort(slice []int) {
	QuickRec(slice, 0, len(slice)-1)
}

// QuickRec 快排递归
func QuickRec(slice []int, sp int, ep int) {
	if sp < ep {
		// 获取中枢值
		DealPivot(slice, sp, ep)
		// 枢纽值
		pivot := ep - 1
		// 左指针
		lp := sp + 1
		// 设右指针为当前枢纽值
		rp := pivot - 1
		for {
			// 如果左指针指向值小于当前枢纽值，则向右移动左指针
			for slice[lp] < slice[pivot] {
				lp++
			}
			/**
			如果右指针大于起始指针位置，并且当前右指针指向值
			大于枢纽值，则向左移动右指针
			*/
			for rp > sp && slice[rp] >= slice[pivot] {
				rp--
			}
			// 左指针未和右指针发生碰撞,左指针和右指针交换指向值
			if lp < rp {
				Swap(&slice[lp], &slice[rp])
			} else {
				// 左右双指针发生碰撞遍历结束
				break
			}
		}
		// 如果左指针和结束指针未碰撞，左指针指向值和枢纽值交换
		if lp < ep {
			Swap(&slice[lp], &slice[pivot])
		}
		// 递归排左
		QuickRec(slice, sp, lp-1)
		// 递归排右
		QuickRec(slice, lp+1, ep)
	}
}

// DealPivot 确定枢纽 三数取中
// 例 ： [3,2,5,84,23,11] -> [3,2,5,23,11,84]
func DealPivot(slice []int, sp int, ep int) {
	mid := (sp + ep) >> 1
	if slice[sp] > slice[mid] {
		Swap(&slice[sp], &slice[mid])
	}
	if slice[sp] > slice[ep] {
		Swap(&slice[sp], &slice[ep])
	}
	if slice[ep] < slice[mid] {
		Swap(&slice[ep], &slice[mid])
	}
	Swap(&slice[ep-1], &slice[mid])
}

// MergeSort 归并排序 效率吊且稳定,赞
func MergeSort(slice []int) {
	// 排序前创建临时slice，而不在递归里反复开辟内存
	tempSlice := make([]int, len(slice))
	MergeRec(slice, 0, len(slice)-1, tempSlice)
}

// MergeRec 归并递归
func MergeRec(slice []int, lp int, rp int, tempSlice []int) {
	if lp < rp {
		mid := (lp + rp) >> 1
		// 递归拆分
		MergeRec(slice, lp, mid, tempSlice)
		MergeRec(slice, mid+1, rp, tempSlice)
		// 开始合并
		MergeSolve(slice, lp, mid, rp, tempSlice)
	}
}

// MergeSolve 归并实现
func MergeSolve(slice []int, lp int, mid int, rp int, tempSlice []int) {
	i := lp
	j := mid + 1
	// temp临时指针
	tp := 0
	for i <= mid && j <= rp {
		if slice[i] <= slice[j] {
			tempSlice[tp] = slice[i]
			i++
		} else {
			tempSlice[tp] = slice[j]
			j++
		}
		tp++
	}
	for i <= mid {
		tempSlice[tp] = slice[i]
		tp++
		i++
	}
	for j <= rp {
		tempSlice[tp] = slice[j]
		tp++
		j++
	}
	// 重置临时指针
	tp = 0
	for lp <= rp {
		slice[lp] = tempSlice[tp]
		lp++
		tp++
	}
}

// ShellSort 壳排序 O(n^1.3)  效率低，还是不用
func ShellSort(slice []int) {
	h := 1
	for h <= len(slice)/3 {
		h = h*3 + 1
	}
	for gap := h; gap > 0; gap = (gap - 1) / 3 {
		for i := gap; i < len(slice); i++ {
			for j := i; j > gap-1; j -= gap {
				if slice[j] < slice[j-gap] {
					Swap(&slice[j], &slice[j-gap])
				}
			}
		}
	}
}

// InsertionSort 插入排序 O(n^2)  效率太低、不用
func InsertionSort(slice []int) {
	for i := 1; i < len(slice); i++ {
		for j := i; j > 0; j-- {
			if slice[j] < slice[j-1] {
				Swap(&slice[j], &slice[j-1])
			}
		}
	}
}

// BubbleSort 冒泡排序 O(n^2) 效率太低、不用
func BubbleSort(slice []int) {
	for i := len(slice) - 1; i > 0; i-- {
		for j := 0; j < i; j++ {
			if slice[j] > slice[j+1] {
				Swap(&slice[j], &slice[j+1])
			}
		}
	}
}

// SelectionSort 选择排序 O(n^2) 效率太低、不用
func SelectionSort(slice []int) {
	leftP := 0
	rightP := len(slice) - 1
	for leftP < rightP {
		minP := leftP
		maxP := rightP
		for i := leftP; i <= rightP; i++ {
			if slice[i] < slice[minP] {
				minP = i
			}
			if slice[i] > slice[maxP] {
				maxP = i
			}
		}
		Swap(&slice[maxP], &slice[rightP])
		if minP == rightP {
			minP = maxP
		}
		Swap(&slice[minP], &slice[leftP])
		leftP++
		rightP--
	}
}

// Swap 数组内的变量交换
func Swap(p *int, sp *int) {
	temp := *p
	*p = *sp
	*sp = temp
}
```

### 算法验证：
产生最够多的样本，用已确定正确的算法计算，再用自己编写的算法计算。  
结果一致，表示算法有效