# 数据结构与算法

## 数据结构：

### 数组：
连续的一组数据，在内存中的分配也是连续的，每个数组中的元素都有其下标，  
用于标识其元素在组中的位置。数组长度不可变，当修改数组时，其本质是复制  
一个新的数组做返回
#### 特点：
1. 查找数据快，直接使用下标，时间复杂度O(1)  

2. 修改慢，因为数组的修改意味着重新生成一个新的数组

### 栈
栈是一种特殊的线性表，只允许操作栈顶，和弹夹一模一样，当装子弹时，其实  
就是操作数据入栈，开枪时，就是操作数据出栈。（先进后出）

### 队列
队列和栈一样，也是一种线性表，不同的是，队列可以在一端加入元素，叫做入  
队。然后被加入的元素在另一端取出，叫做出队。（先进先出）

### 链表
链表是物理存储单元上非连续、非顺序的存储结构。其每个元素包含两个节点，一  
个是包含存储数据的元素，一个是指向下一个元素地址的指针。
#### 特点：
1. 查找数据慢，需要遍历查找目标位置之前的所有元素,时间复杂度O(n)  

2. 修改快，只需要修改前一个元素的指针指向，和插入元素的指针指向


### 红黑树
1. 每个节点或者是黑色，或者是红色。
2. 根节点是黑色。
3. 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
4. 如果一个节点是红色的，则它的子节点必须是黑色的。
5. 从一个节点到该节点的叶子节点的所有路径上包含相同数目的黑节点。


## 算法（PS：所有log的底数为2 ）：
如何测算算法的优劣？  
1. 时间测算：计算速度越快，算法越优秀。  

2. 空间测算：计算时所需要额外的空间越小，算法越优秀。

### BIG-O：
BIG-O是指随着问题规模的增加，解决其问题的方法所占用的时间和空间的表示。  

### 常见时间复杂度（效率从高到低）： 

- **O(1)常数介：**当问题增大n倍，花费时间为1 

- **O(logn)对数介：**当问题增大n倍，花费时间为logn倍

- **O(n)线性介：**当问题增大n倍，花费时间为n倍  

- **O(nlogn)nlogn介：**当问题增大n倍，花费时间为n * logn倍  

- **O(n^2)平方介：**当问题增大n倍，花费时间为n * n倍  

- **O(n^3)立方介：**当问题增大n倍，花费时间为n * n * n倍  

- **O(2^n)指数介：**当问题增大n倍，花费时间为2的n次幂倍  

- **O(n!)阶乘介：**当问题增大n倍，花费时间为1 * 2 * 3 ... * n

### 常用排序算法：

| 中文 | 英文 | 平均复杂度 | 最坏复杂度 | 最好复杂度 | 空间复杂度 | 是否稳定 |
| ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| 选择排序 | selection | n^2 | n^2 | n^2 | 1 | false |
| 冒泡排序 | bubble | n^2 | n^2 | n | 1 | true |
| 插入排序 | insertion | n^2 | n^2 | n | 1 | true |
| 堆排序 | heap | nlogn | nlogn | nlogn | 1 | false |
| 壳排序 | shell | n^1.3 | n^2 | n | 1 | false |
| 归并排序 | merge | nlogn | nlogn | nlogn | n | true |
| 快速排序 | quick | nlogn | n^2 | nlogn | logn | false |
| 桶排序 | bucket | n+k | n^2 | n | n+k | true |
| 计数排序 | counting | n+k | n+k | n+k | n+k | true |
| 基数排序 | radix | n * k | n * k | n * k | n+k | true |

### 编写算法思路：
1. 由简单至复杂，逐步验证。  

2. 先局部后整体。  

3. 边界处理，优化可读性。  

### GO代码实现：
```go
// QuickSort 快速排序 效率虽吊但是不稳定,赞
func QuickSort(slice []int) {
	QuickRec(slice, 0, len(slice)-1)
}

// QuickRec 快排递归
func QuickRec(slice []int, sp int, ep int) {
	if sp < ep {
		// 获取中枢值
		DealPivot(slice, sp, ep)
		// 枢纽值
		pivot := ep - 1
		// 左指针
		lp := sp + 1
		// 设右指针为当前枢纽值
		rp := pivot - 1
		for {
			// 如果左指针指向值小于当前枢纽值，则向右移动左指针
			for slice[lp] < slice[pivot] {
				lp++
			}
			/**
			如果右指针大于起始指针位置，并且当前右指针指向值
			大于枢纽值，则向左移动右指针
			*/
			for rp > sp && slice[rp] >= slice[pivot] {
				rp--
			}
			// 左指针未和右指针发生碰撞,左指针和右指针交换指向值
			if lp < rp {
				Swap(&slice[lp], &slice[rp])
			} else {
				// 左右双指针发生碰撞遍历结束
				break
			}
		}
		// 如果左指针和结束指针未碰撞，左指针指向值和枢纽值交换
		if lp < ep {
			Swap(&slice[lp], &slice[pivot])
		}
		// 递归排左
		QuickRec(slice, sp, lp-1)
		// 递归排右
		QuickRec(slice, lp+1, ep)
	}
}

// DealPivot 确定枢纽 三数取中
// 例 ： [3,2,5,84,23,11] -> [3,2,5,23,11,84]
func DealPivot(slice []int, sp int, ep int) {
	mid := (sp + ep) >> 1
	if slice[sp] > slice[mid] {
		Swap(&slice[sp], &slice[mid])
	}
	if slice[sp] > slice[ep] {
		Swap(&slice[sp], &slice[ep])
	}
	if slice[ep] < slice[mid] {
		Swap(&slice[ep], &slice[mid])
	}
	Swap(&slice[ep-1], &slice[mid])
}

// MergeSort 归并排序 效率吊且稳定,赞
func MergeSort(slice []int) {
	// 排序前创建临时slice，而不在递归里反复开辟内存
	tempSlice := make([]int, len(slice))
	MergeRec(slice, 0, len(slice)-1, tempSlice)
}

// MergeRec 归并递归
func MergeRec(slice []int, lp int, rp int, tempSlice []int) {
	if lp < rp {
		mid := (lp + rp) >> 1
		// 递归拆分
		MergeRec(slice, lp, mid, tempSlice)
		MergeRec(slice, mid+1, rp, tempSlice)
		// 开始合并
		MergeSolve(slice, lp, mid, rp, tempSlice)
	}
}

// MergeSolve 归并实现
func MergeSolve(slice []int, lp int, mid int, rp int, tempSlice []int) {
	i := lp
	j := mid + 1
	// temp临时指针
	tp := 0
	for i <= mid && j <= rp {
		if slice[i] <= slice[j] {
			tempSlice[tp] = slice[i]
			i++
		} else {
			tempSlice[tp] = slice[j]
			j++
		}
		tp++
	}
	for i <= mid {
		tempSlice[tp] = slice[i]
		tp++
		i++
	}
	for j <= rp {
		tempSlice[tp] = slice[j]
		tp++
		j++
	}
	// 重置临时指针
	tp = 0
	for lp <= rp {
		slice[lp] = tempSlice[tp]
		lp++
		tp++
	}
}

// ShellSort 壳排序 O(n^1.3)  效率低，还是不用
func ShellSort(slice []int) {
	h := 1
	for h <= len(slice)/3 {
		h = h*3 + 1
	}
	for gap := h; gap > 0; gap = (gap - 1) / 3 {
		for i := gap; i < len(slice); i++ {
			for j := i; j > gap-1; j -= gap {
				if slice[j] < slice[j-gap] {
					Swap(&slice[j], &slice[j-gap])
				}
			}
		}
	}
}

// InsertionSort 插入排序 O(n^2)  效率太低、不用
func InsertionSort(slice []int) {
	for i := 1; i < len(slice); i++ {
		for j := i; j > 0; j-- {
			if slice[j] < slice[j-1] {
				Swap(&slice[j], &slice[j-1])
			}
		}
	}
}

// BubbleSort 冒泡排序 O(n^2) 效率太低、不用
func BubbleSort(slice []int) {
	for i := len(slice) - 1; i > 0; i-- {
		for j := 0; j < i; j++ {
			if slice[j] > slice[j+1] {
				Swap(&slice[j], &slice[j+1])
			}
		}
	}
}

// SelectionSort 选择排序 O(n^2) 效率太低、不用
func SelectionSort(slice []int) {
	leftP := 0
	rightP := len(slice) - 1
	for leftP < rightP {
		minP := leftP
		maxP := rightP
		for i := leftP; i <= rightP; i++ {
			if slice[i] < slice[minP] {
				minP = i
			}
			if slice[i] > slice[maxP] {
				maxP = i
			}
		}
		Swap(&slice[maxP], &slice[rightP])
		if minP == rightP {
			minP = maxP
		}
		Swap(&slice[minP], &slice[leftP])
		leftP++
		rightP--
	}
}

// Swap 数组内的变量交换
func Swap(p *int, sp *int) {
	temp := *p
	*p = *sp
	*sp = temp
}
```

### 算法验证：
产生最够多的样本，用已确定正确的算法计算，再用自己编写的算法计算。  
结果一致，表示算法有效


