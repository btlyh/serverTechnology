# 数据结构与算法

## 数据结构：

### 数组：
连续的一组数据，在内存中的分配也是连续的，每个数组中的元素都有其下标，  
用于标识其元素在组中的位置。数组长度不可变，当修改数组时，其本质是复制  
一个新的数组做返回
#### 特点：
1. 查找数据快，直接使用下标，时间复杂度O(1)  

2. 修改慢，因为数组的修改意味着重新生成一个新的数组

### 栈
栈是一种特殊的线性表，只允许操作栈顶，和弹夹一模一样，当装子弹时，其实  
就是操作数据入栈，开枪时，就是操作数据出栈。（先进后出）

### 队列
队列和栈一样，也是一种线性表，不同的是，队列可以在一端加入元素，叫做入  
队。然后被加入的元素在另一端取出，叫做出队。（先进先出）

### 链表
链表是物理存储单元上非连续、非顺序的存储结构。其每个元素包含两个节点，一  
个是包含存储数据的元素，一个是指向下一个元素地址的指针。
#### 特点：
1. 查找数据慢，需要遍历查找目标位置之前的所有元素,时间复杂度O(n)  

2. 修改快，只需要修改前一个元素的指针指向，和插入元素的指针指向

## 算法（PS：所有log的底数为2 ）：
如何测算算法的优劣？  
1. 时间测算：计算速度越快，算法越优秀。  

2. 空间测算：计算时所需要额外的空间越小，算法越优秀。

### BIG-O：
BIG-O是指随着问题规模的增加，解决其问题的方法所占用的时间和空间的表示。  

### 常见时间复杂度（效率从高到低）： 

- **O(1)常数介：**当问题增大n倍，花费时间为1 

- **O(logn)对数介：**当问题增大n倍，花费时间为logn倍

- **O(n)线性介：**当问题增大n倍，花费时间为n倍  

- **O(nlogn)nlogn介：**当问题增大n倍，花费时间为n * logn倍  

- **O(n^2)平方介：**当问题增大n倍，花费时间为n * n倍  

- **O(n^3)立方介：**当问题增大n倍，花费时间为n * n * n倍  

- **O(2^n)指数介：**当问题增大n倍，花费时间为2的n次幂倍  

- **O(n!)阶乘介：**当问题增大n倍，花费时间为1 * 2 * 3 ... * n

### 常用排序算法：

| 中文 | 英文 | 平均复杂度 | 最坏复杂度 | 最好复杂度 | 空间复杂度 | 是否稳定 |
| ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| 选择排序 | selection | n^2 | n^2 | n^2 | 1 | false |
| 冒泡排序 | bubble | n^2 | n^2 | n | 1 | true |
| 插入排序 | insertion | n^2 | n^2 | n | 1 | true |
| 堆排序 | heap | nlogn | nlogn | nlogn | 1 | false |
| 壳排序 | shell | n^1.3 | n^2 | n | 1 | false |
| 归并排序 | merge | nlogn | nlogn | nlogn | n | true |
| 快速排序 | quick | nlogn | n^2 | nlogn | logn | false |
| 桶排序 | bucket | n+k | n^2 | n | n+k | true |
| 计数排序 | counting | n+k | n+k | n+k | n+k | true |
| 基数排序 | radix | n * k | n * k | n * k | n+k | true |

### 编写算法思路：
1. 由简单至复杂，逐步验证。  

2. 先局部后整体。  

3. 边界处理，优化可读性。  

### GO代码实现：
```golang
// SelectionSort 选择排序
func SelectionSort(slice []int) {
	for i := 0; i < len(slice)-1; i++ {
		minPos := i
		for j := i + 1; j < len(slice); j++ {
			if slice[j] < slice[minPos] {
				minPos = j
			}
		}
		if i != minPos {
			Swap(slice, i, minPos)
		}
	}
}

// Swap 数组内的变量交换
func Swap(arr []int, p int, sp int) {
	arr[p] ^= arr[sp]
	arr[sp] ^= arr[p]
	arr[p] ^= arr[sp]
}

```