# 分布式锁

ps：本篇所有《单机》都是特指单个物理机

## 本地锁与分布式锁的异同：
1.本地锁只用于单机本地的多线程、多进程进行竞争  

2.分布式锁用于多机的多线程、多进程进行竞争

3.使用分布式锁相对于本地锁，会造成性能有所下降  


### 分布式锁模型：
![分布式锁模型图](https://github.com/btlyh/serverTechnology/blob/main/img/dLock.png "简单模型")  

***

## 当使用分布式锁之后，还需要再使用本地所吗？
需要的，如果本地是多线程、多线程模型的结构应用，竞争锁时，一定是存在  
并发的，但最终竞争者的执行线程只有一个，所以在竞争锁的时候，我们更期  
望，单机只有一条请求去竞争分布式锁，这样才能提升效率，降低无畏的资源  
浪费，所以，才需要在多线程情况下，竞争分布式锁的时候，先在本地进行本  
地锁的竞争。

***

## 两大类分布式锁：

### 1.类CAS自旋式的分布式锁：

以**redis**和**mysql**为典型代表的，会使用IO轮询的方式，来不断的  
尝试加锁的方式。

#### redis举例：
a.redis的worker单线程特质，可以非常方便的来做分布式锁，也自带了setnx()  
本地方法来进行加锁吗，此方法也可以设置锁的timeout，设置timeout是  
为了避免死锁的出现

b.当多个竞争者来竞争redis分布式锁式，未竞争成功的竞争者则会开始以  
网络IO轮询的方式，尝试获取锁。

c.上述“b”的描述其实不是我们正常期望的状况，因此可以使用发布订阅的方  
式来减少竞争者轮询的次数，也就是说，当竞争者去获得分布式锁的时候发  
布关于此锁的数据信息，而其他未获得锁的竞争者可以订阅此信息，当锁归  
还的时候，通过发布订阅的方式通知其他竞争者再来竞争锁。

d.同时，获取到锁的竞争者也需要再开辟一个新的监控线程来监控当前锁的  
超时时间，当竞争者的业务处理时间大于了超时时间，则需要监控线程来处  
理锁续约的业务。

如果为了解决单点故障的，可以使用**redlock的算法**来处理这样的业  
务场景。

### redlock模型：
![redlock模型模型图](https://github.com/btlyh/serverTechnology/blob/main/img/tradeoff.png "简单模型")  

1.当竞争者获得过半的“锁”，就可以获得锁。  

2.如果竞争者没有获得过半返回的情况下则进行随机sleep，然后再次重新  
去竞争锁

3.且如果发生单点故障，宕机一个节点，也不会导致竞争锁服务停止。  

**使用这种方式做分布式锁，是比较极限的一种做法**  


### 2.事件通知式的分布式锁：

以**zk**和**etcd**为典型代表的，当锁发生变化式，会以事件形式通知  
或唤醒他竞争者来尝试加锁的方式。


#### zk举例：
zk的特质决定，zk的分布式锁可以是事件通知的方式。 

a.zk的session是同步至follower的，对于竞争者是无感的，只要不是所有  
节点都宕机，竞争者的session一直都存在。 

b.zk可以创建临时node，而临时node的生命周期是和session绑定的。  

c.zk的watch监控回调机制，支持针对于临时node改变的回调函数  

(类似于redis的订阅发布了)
